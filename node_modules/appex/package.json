{
  "name": "appex",
  "version": "0.6.8",
  "description": "develop nodejs web applications with typescript",
  "main": "index.js",
  "directories": {},
  "dependencies": {
    "typescript.api": "0.7.7"
  },
  "devDependencies": {},
  "scripts": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/sinclairzx81/appex"
  },
  "keywords": [
    "typescript",
    "web api",
    "reflection",
    "compiler",
    "schema",
    "templates",
    "sitemap"
  ],
  "author": {
    "name": "sinclair"
  },
  "licenses": [
    {
      "type": "The MIT License (MIT)",
      "url": "https://raw.github.com/sinclairzx81/appex/master/license.txt"
    }
  ],
  "readmeFilename": "readme.md",
  "readme": "![](https://raw.github.com/sinclairzx81/appex/master/artifacts/logo.jpg)\r\n\r\n### develop nodejs web applications with [typescript](http://www.typescriptlang.org/)\r\n\r\n\r\n```typescript\r\n//----------------------------------------------\r\n// app.js\r\n//----------------------------------------------\r\n\r\nvar appex = require('appex');\r\n\r\nvar app = appex({ program : './program.ts' });\r\n\r\napp.listen(3000);\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\n/// <reference path=\"node_modules/appex/appex.d.ts\" />\r\n\r\nexport function index(context:appex.web.IContext) {\r\n\t\r\n\tcontext.response.send('home page');\r\n}\r\n\r\nexport function about(context:appex.web.IContext) {\r\n\t\r\n\tcontext.response.send('about page');\r\n}\r\n\r\nexport function wildcard (context:appex.web.IContext, path:string) {\r\n    \r\n    context.response.send(404, path + \" not found\");\r\n}\r\n\r\n```\r\n### install\r\n\r\n```\r\nnpm install appex\r\n```\r\n### contents\r\n\r\n* [getting started](#getting_started)\r\n\t* [create a application](#application)\r\n\t* [start up options](#options)\r\n\t* [running on an existing http server](#http_server)\r\n\t* [running as express middleware](#express_middleware)\r\n* [http handlers](#http_handlers)\r\n\t* [context](#context)\r\n\t* [request](#request)\r\n\t* [response](#response)\r\n\t* [routing](#routing)\r\n\t* [signatures](#signatures)\r\n\t* [named handlers](#named_handlers)\r\n\t* [index handlers](#index_handlers)\r\n\t* [wildcard handlers](#wildcard_handlers)\r\n\t* [attributes](#attributes)\r\n\t* [verbs](#verbs)\r\n\t* [url rewrite](#url_rewrite)\r\n\t* [middleware](#middleware)\r\n\t* [exporting functions](#exporting_functions)\r\n\t* [handling 404](#handling_404)\r\n\t* [serving static files](#serving_static_files)\r\n* [templating](#templating)\r\n\t* [overview](#template_overview)\r\n\t* [context](#template_context)\t\r\n\t* [syntax](#template_syntax)\r\n\t* [layouts and sections](#template_layouts_and_sections)\r\n\t* [render](#template_render)\r\n\t* [caching and devmode](#caching_and_devmode)\r\n* [sitemaps](#sitemaps)\r\n\t* [generating](#sitemap_generate)\r\n\t* [metadata](#sitemap_metadata)\r\n* [json schema](#json_schema)\r\n\t* [generating schema](#generating_schema)\r\n\t* [validating json](#validating_json)\r\n\t* [web service descriptions](#web_service_descriptions)\r\n* [reflection](#reflection)\r\n\t* [reflect everything](#reflect_everything)\r\n\t* [reflect specific types](#reflect_specific_types)\r\n* [developing with appex](#developing_with_appex)\r\n\t* [appex.d.ts declaration](#appex_declaration)\r\n\t* [structuring projects](#structuring_projects)\r\n* [additional resources](#resources)\r\n* [license](#license)\r\n\r\n<a name=\"getting_started\" />\r\n## getting started\r\n\r\nThe following sections outline creating appex applications and configuration.\r\n\r\n<a name=\"application\" />\r\n### create a application\r\n\r\nThe following code will create a standalone appex application and \r\nhttp server and listen on port 3000.\r\n\r\n```typescript\r\nvar appex   = require('appex');\r\n\r\nvar app   = appex({ program : './program.ts', \r\n                    devmode : true,\r\n                    logging : true });\r\n\r\napp.listen(3000);\r\n```\r\n\r\nnote: devmode and logging are optional. however, when developing \r\nwith appex, it is helpful to have these enabled.\r\n\r\n<a name=\"options\" />\r\n### start up options\r\n\r\nappex accepts the following start up options.\r\n\r\n```typescript\r\nvar options = {\r\n\r\n\t// (required) location of source file.\r\n\tprogram    : './program.ts', \r\n\r\n\t// (optional) recompile on request. (default:false) \r\n\tdevmode    : true,          \r\n\r\n\t// (optional) log to stdout. (default:false) \r\n\tlogging    : true,\r\n\r\n\t// (optional) user defined objects added to the app context.\r\n\tcontext    : {}\r\n};\r\n\r\nvar app = appex( options );\r\n```\r\n\r\n<a name=\"http_server\" />\r\n### running on an existing http server\r\n\r\nThe following demonstrates setting up appex on an existing nodejs http server. In \r\nthis example, appex will attempt to handle incoming requests, and if appex cannot\r\nroute the request, will fire the callback.\r\n\r\n```typescript\r\nvar http  = require('http');\r\n\r\nvar appex = require('appex');\r\n\r\nvar app = appex({ program : './program.ts' });\r\n\r\nvar server = http.createServer(function(req, res){\r\n\r\n    app(req, res, function() { // appex handler...\r\n\t\t\r\n\t\t// not handled.\r\n\r\n\t}); \r\n});\r\n\r\nserver.listen(3000);\r\n```\r\n\r\n<a name=\"express_middleware\" />\r\n### running as express middleware\r\n\r\nappex allows developers to augment existing express / connect applications by \r\nway of middleware. The following demonstrates setting up appex as express middleware.\r\n\r\n```typescript\r\nvar express = require('express');\r\n\r\nvar appex = require('appex');\r\n\r\nvar app = express();\r\n\r\napp.use( appex({ program : './program.ts' }) ); \r\n\r\napp.get('/', function(req, res) {\r\n\r\n  res.send('Hello World');\r\n  \r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\nLike in the \"running on an existing http server\" example above, appex will attempt to intercept incoming requests. \r\nif appex cannot find a matching route for the request, it will automatically call the \"next\" function to pass the request \r\non to the next middleware or express handler.\r\n\r\nin addition to this, appex may also act as traditional express middleware. In the example below, a appex wildcard\r\nfunction is created which will match \"all\" incoming requests, the wildcard function simply prints hello world to \r\nthe console and then calls context.next(), which passes the request on the express handler.\r\n\r\n```typescript\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\n// http:[host]:[port]/(.*)\r\nexport function wildcard(context, path) {\r\n\r\n\tconsole.log('hello world!!');\r\n\r\n\tcontext.next(); // pass it on!\r\n}\r\n\r\n//----------------------------------------------\r\n// app.js\r\n//----------------------------------------------\r\n\r\nvar express = require('express');\r\n\r\nvar appex = require('appex');\r\n\r\nvar app = express();\r\n\r\napp.use( appex({ program : './program.ts' }) );\r\n\r\napp.get('/', function(req, res) {\r\n\r\n  res.send('Hello World');\r\n  \r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\nJust like traditional express middleware, appex will also inheriate the characteristics of the request.\r\n\r\nconsider the following example in which the jade view engine is configured for use. appex will inheritate the \r\nresponse.render() method, which is passed to the appex handler as context.response.render()\r\n\r\n```typescript\r\n//----------------------------------------------\r\n// app.js\r\n//----------------------------------------------\r\n\r\napp.configure(function(){\r\n\r\n  app.set('views', __dirname + '/views');\r\n  \r\n  // set up the jade engine.\r\n  app.set('view engine', 'jade'); \r\n  \r\n  // bind appex\r\n  app.use( appex({program:'./program.ts', devmode:true} ));  \r\n});\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\n// http:[host]:[port]/\r\nexport function index(context) {\r\n\t\r\n\t// jade renderer works!\r\n\tcontext.response.render('index', { title: 'Express' }); \r\n}\r\n```\r\n\r\n<a name=\"http_handlers\" />\r\n## http handlers\r\n\r\nThe following sections describe how to create http accessible handlers with appex.\r\n\r\n<a name=\"context\" />\r\n### context\r\n\r\nAll appex functions are passed a application context object as their first argument. The app context object \r\nencapulates the http request and response objects issued by the underlying http server, as well as\r\nadditional objects specific to appex. These are listed below:\r\n\r\n```typescript\r\n// the app context\r\nexport function method(context) {\r\n\t\r\n\t// context.request    - the http request object.\r\n\r\n\t// context.response   - the http response object.\r\n\r\n\t// context.attribute    - appex attribute.\r\n\r\n\t// context.next       - the next function (express middleware)\r\n\t\r\n\t// context.router     - the appex router\r\n\r\n\t// context.sitemap    - the appex sitemap api\r\n\r\n\t// context.template   - the appex template engine.\r\n\t\r\n\t// context.module     - the module being run (this module)\r\n\r\n\t// context.schema     - json schema api.\r\n\r\n\t// context.mime       - a http mime type utility.\r\n}\r\n```\r\n\r\nit is possible to extend the default objects passed on the context by adding them on the appex startup options. The \r\nfollowing will attach the async module to the context. \r\n\r\n```typescript\r\n//----------------------------------------------\r\n// app.js\r\n//----------------------------------------------\r\n\r\nvar appex   = require('appex');\r\n\r\nvar app = appex({ program : './program.ts', \r\n\t\t\t\t  devmode : true, \r\n\t\t\t      context: {\r\n\t\t\t\t\t\tasync : require('async')\r\n\t\t\t\t  }});\r\n\r\napp.listen(3000);\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\nexport function index(context) {\r\n\r\n\t// context.async = passed on the context.\r\n\r\n\tcontext.response.send('home page');\r\n}\r\n```\r\n<a name=\"request\" />\r\n### request\r\n\r\nThe appex request is a nodejs http request issued by the underlying node http server. \r\nappex extends the request with convenience methods for reading http request data. These\r\nare outlined below.\r\n\r\nreading a posted string. \r\n```typescript\r\n//----------------------------------------------\r\n// receive request as a string\r\n//----------------------------------------------\r\nexport function submit(context) {\r\n\r\n\tcontext.request.body.recv((str) => {\r\n\r\n\t\t// do something with str\r\n\t})\r\n}\r\n```\r\nreading posted form data as json object.\r\n```typescript\r\n//----------------------------------------------\r\n// receive a form post\r\n//----------------------------------------------\r\nexport function submit(context) {\r\n\r\n\tcontext.request.body.form((obj) => {\r\n\r\n\t\t// do something with obj\r\n\t})\r\n}\r\n```\r\nreading posted json data as a json object.\r\n```typescript\r\n//----------------------------------------------\r\n// receive a json post\r\n//----------------------------------------------\r\nexport function submit(context) {\r\n\r\n\tcontext.request.body.json((obj) => {\r\n\t\t\r\n\t\t// do something with obj\r\n\t})\r\n}\r\n```\r\n\r\nnote: if appex detects that express or connect middleware has already been applied\r\nto the request object, appex will use those instead.\r\n\r\n<a name=\"response\" />\r\n### response\r\n\r\nThe appex response is a nodejs http response issued by the underlying node http server. \r\nappex provides some utility methods for writing http responses. These are outlined below.\r\n\r\n```js\r\n//----------------------------------------------\r\n// the nodejs response has been extended with the following\r\n// signatures.\r\n//----------------------------------------------\r\nexport interface IResponse extends http.ServerResponse {\r\n\t\r\n\tsend (data     : string): void;\r\n\r\n\tsend (data     : NodeBuffer): void;\r\n\r\n\tsend (status   : number, data : string): void;\r\n\r\n\tserve (filepath: string): void;\r\n\r\n\tserve (root : string, filepath: string): void;\r\n\r\n\tserve (root : string, filepath: string, mime:string): void;\r\n\r\n\tjson (obj      : any): void;\r\n\r\n\tjson (status   : number, obj : any): void;\r\n\r\n\tjsonp (obj     : any): void;\r\n\r\n\tjsonp (status  : number, obj : any): void;\r\n\r\n\tjsonp (status  : number, obj : any, callback: string): void;\r\n}\r\n```\r\n\r\nnote: if appex detects that express or connect middleware has already been applied\r\nto for any of the following response methods, appex will use those instead.\r\n\r\n<a name=\"routing\" />\r\n### routing\r\n\r\nappex creates routes based on module scope and function name. consider the following:\r\n\r\n```typescript\r\nexport module services.customers {\r\n\t\r\n\t// url: http://[host]:[port]/services/customers/insert\r\n\texport function insert(context) {\r\n\r\n\t\tcontext.response.send('services.customers.insert')\r\n    }\r\n\t\r\n\t// url: http://[host]:[port]/services/customers/update\r\n\texport function update(context) { \r\n\t\t\r\n\t\tcontext.response.send('services.customers.update')\r\n    }\r\n\t\r\n\t// url: http://[host]:[port]/services/customers/delete\r\n\texport function delete(context) { \r\n\r\n\t\tcontext.response.send('services.customers.delete')\r\n\t}\r\n}\r\n\r\n// url: http://[host]:[port]/\r\nexport function index   (context) { \r\n\r\n\tcontext.response.send('home page')\r\n}\r\n\r\n// url: http://[host]:[port]/about\r\nexport function about   (context) { \r\n\r\n\tcontext.response.send('about page')\r\n}\r\n\r\n// url: http://[host]:[port]/contact\r\nexport function contact (context) { \r\n\r\n\tcontext.response.send('contact page')\r\n}\r\n\r\n// url: http://[host]:[port]/(.*)\r\nexport function wildcard (context, path) {\r\n\r\n\tcontext.response.send(404, path + ' not found')\r\n}\r\n\r\n```\r\n\r\n<a name=\"signatures\" />\r\n### signatures\r\n\r\nappex supports three function signatures for http routing (named, index and wildcard). Functions that\r\ndo not apply these signatures will not be routed.\r\n\r\n<a name=\"named_handlers\" />\r\n### named handlers\r\n\r\nNamed handlers resolve urls to their current module scope + the name of the function.\r\n\r\nNamed handlers require the following signature:\r\n\r\n* name        - 'anything'\r\n* argument[0] - app context\r\n* returns     - void (optional)\r\n\r\n```typescript\r\n\r\n// http://[host]:[port]/about\r\nexport function about(context) {\r\n\r\n\tcontext.response.send('about page');\r\n}\r\n\r\n// http://[host]:[port]/users/login\r\nexport module users {\r\n\r\n\texport function login(context) {\r\n\t\t\r\n\t\tcontext.response.send('handle login');\t\r\n\t}\r\n}\r\n\r\n```\r\n\r\n<a name=\"index_handlers\" />\r\n### index handlers\r\n\r\nIndex handlers resolve urls to their current module scope.\r\n\r\nIndex handlers require the following signature:\r\n\r\n* name        - 'index'\r\n* argument[0] - app context\r\n* returns     - void (optional)\r\n\r\n```typescript\r\n// url: http://[host]:[port]/\r\nexport function index(context) { \r\n\r\n\tcontext.response.send('home page');\r\n}\r\n\r\nexport module blogs {\r\n\t\r\n\t// url: http://[host]:[port]/blogs\r\n\texport function index  (context) \r\n\t{\t\r\n\t\tcontext.response.send('blog index');\r\n\t}\r\n}\r\n```\r\n\r\n<a name=\"wildcard_handlers\" />\r\n### wildcard handlers\r\n\r\nWildcard handlers resolve their urls to their current module scope + url.\r\n\r\nappex wildcard handlers allow for wildcard routing at a given module scope. Wildcard handlers\r\nsupport 'typed' url argument mapping, as denoted by the arguments annotation.\r\n\r\nIn addition, wildcard handlers also support optional arguments which can be specified with TypeScript's '?' \r\non argument names.\r\n\r\nappex wildcard handlers require the following signature:\r\n\r\n* name        - 'wildcard'\r\n* argument[0] - app context\r\n* argument[n] - 1 or more arguments to be mapped from the url\r\n* returns     - void (optional)\r\n\r\n```typescript\r\ndeclare var console;\r\n\r\nexport module blogs {\r\n\t\r\n\t// url : http://[host]:[port]/blogs/2013/1/11   - matched\r\n\r\n\t// url : http://[host]:[port]/blogs/2013/01/11  - matched\r\n\r\n\t// url : http://[host]:[port]/blogs/2013/01/3rd - not matched - (see number annotation)\r\n\r\n\t// url : http://[host]:[port]/blogs/2013/01     - matched     - (see ? annotation)\r\n\r\n\t// url : http://[host]:[port]/blogs/2013        - not matched - (month is required)\r\n\t\r\n    export function wildcard(context, year:number, month:number, day?:number) {\r\n\r\n        context.response.json({ year: year, month: month, day: day})\r\n    }\r\n}\r\n\r\n// url : http://[host]:[port]/\r\nexport function index(context) {\r\n\r\n\tcontext.response.send('home');\r\n}\r\n\r\n// url : http://[host]:[port]/(.*) \r\nexport function wildcard(context, path) {\r\n\r\n\tcontext.response.send(404, 'not found');\r\n}\r\n\r\n```\r\nnote: appex supports boolean, number, string and any annotations on wildcard arguments. if no annotation\r\nis specified, appex interprets the argument as a string. the type 'any' is also interpreted as string.\r\n\r\nnote: wildcard functions should be declared last in any module scope. this ensures other routes\r\nwill be matched first.\r\n\r\n<a name=\"attributes\" />\r\n### attributes\r\n\r\nappex supports a attribute scheme which developers can use to decorate modules and functions with \r\ndeclaritive metadata. appex attributes can set by calling the attribute('qualifier', data)\r\nfunction which is passed to the appex module on the global scope.\r\n\r\nunlike traditional attributes (in languages like C sharp) appex attributes have a cascading behaviour\r\nwhich allows developers to apply metadata at a lexical scope, and have it cascade through to descendant scopes.\r\n\r\nThe following outlines this behavour.\r\n\r\n```typescript\r\n/// <reference path=\"node_modules/appex/appex.d.ts\" />\r\n\r\nattribute({a: 10}); // global.\r\n\r\nattribute('foo', {b : 20})\r\nexport module foo {\r\n\r\n    attribute('foo.bar', {c : 30})\r\n    export module bar {\r\n            \r\n        attribute('foo.bar.index', {d : 40})\r\n        export function index(context) {\r\n        \r\n            //context.attribute\r\n            //{\r\n            //    \"a\": 10,\r\n            //    \"b\": 20,\r\n            //    \"c\": 30,\r\n\t\t\t//    \"d\": 40\r\n            //}\r\n\r\n            context.response.json( context.attribute );       \r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nin addition, appex recognizes three types of attributes. developers can use these to override the default \r\nbahavour of the appex router and apply url rewriting (urls), verb matching (verbs) and middleware (use),\r\nas demonstrated below.\r\n\r\n```typescript\r\n/// <reference path=\"node_modules/appex/appex.d.ts\" />\r\n\r\nfunction logger(context) {\r\n\tconsole.log('logging')\r\n\tcontext.next()\r\n}\r\n\r\n// invoke 'logger' middleware.\r\nattribute('index', {use   : [logger]})   \r\n\r\n// override the default route.\r\nattribute('index', {urls  : ['/', '/home']})  \r\n\r\n// only accept GET requests.\r\nattribute('index', {verbs : ['GET']})    \r\n\r\nexport function index(context:appex.web.IContext) {\r\n\t\r\n\tcontext.response.send('home page')\r\n}\r\n```\r\n\r\n<a name=\"verbs\" />\r\n### verbs\r\n\r\nappex handles http verb matching with attributes. appex will recognise the \r\n'verbs' property applied to the attribute to match against http verbs.\r\n\r\n```typescript\r\nattribute('index', { verbs: ['GET'] })\r\nexport function index (context) { \r\n        \r\n    // only allow HTTP GET requests\r\n    context.response.send('index')\r\n}\r\n\r\nattribute('submit', { verbs: ['POST', 'PUT'] })\r\nexport function submit (context) { \r\n    \r\n    // only allow HTTP POST and PUT requests\r\n    context.response.send('submit')\r\n}\r\n```\r\n\r\n<a name=\"url_rewrite\" />\r\n### url rewrite\r\n\r\ndevelopers can rewrite the default route given to exported functions with the 'urls' property applied\r\nto the attribute. \r\n\r\n```typescript\r\nattribute('index', { urls: ['/', '/home', 'home.html'] })\r\nexport function index (context) { \r\n    \r\n    context.response.send('index')\r\n}\r\n```\r\nnote: url rewriting is only available on index and named routes.\r\n\r\nnote: rewriting with regular expressions is currently not supported.\r\n\r\n<a name=\"middleware\" />\r\n### middleware\r\n\r\nappex supports middleware with attributes. appex middleware defined with attributes allows\r\ndevelopers to scope middleware on single functions, or entire module scopes. appex will \r\nrecognise the 'use' property applied to the attribute to invoke middleware.\r\n\r\nthe following demonstrates how one might use middleware to secure a site admin.\r\n\r\nnote: middleware 'must' call next or handle the request. \r\n\r\n```typescript\r\ndeclare function attribute (qualifier:string, obj:any);\r\n\r\ndeclare var console;\r\n\r\nfunction authenticate(context) {\r\n\r\n    console.log('authenticate')\r\n\r\n\t// call next() if authenticated, otherwise, handle the response.\r\n    context.next(); \r\n}\r\n\r\nfunction authorize(context) {\r\n\r\n    console.log('authorize')\r\n\r\n\t// call next() if authorized, otherwise, handle the response.\r\n    context.next(); \r\n}\r\n\r\n// apply security middleware to admin scope.\r\nattribute('admin', {use: [authenticate, authorize]}) \r\nexport module admin {\r\n\r\n    export function index(context) {\r\n        \r\n        console.log(context.attribute); // view attribute\r\n\r\n        context.response.send('access granted!')\r\n    }\r\n}\r\n\r\n// index handler has no middleware applied.\r\nexport function index (context) { \r\n    \r\n    console.log(context.attribute); // view attribute\r\n\r\n    context.response.send('home')\r\n}\r\n```\r\n\r\n\r\n<a name=\"exporting_functions\" />\r\n### exporting functions\r\n\r\nappex will only route functions prefixed with the TypeScript 'export' declarer. This rule\r\nalso applied to modules. Developers can use this to infer notions of public and private \r\nat the http level.\r\n\r\nconsider the following example:\r\n\r\n```typescript\r\n\r\n// module is not exported, and is \r\n// therefore private.\r\nmodule private_module {\r\n\t\r\n\t// function is exported, yet private \r\n\t// as a http endpoint due to the \r\n\t// parent module being private.\r\n\texport function public_method () { }\r\n\t\r\n\t// function is not exported, and is \r\n\t// private to this module.\r\n\tfunction private_method() { }\r\n}\r\n\r\n// function is not exported, and \r\n// is therefore private.\r\nfunction private_function() { }\r\n\r\n// function is exported, and therefore \r\n// publically accessible.\r\nexport function public_function   (context) { \r\n\t\r\n\t// this function can invoke \r\n\t// private functions.\r\n\tprivate_function(); // ok\r\n\t\r\n\t// calling exported method in \r\n\t// private module\r\n\tprivate_module.public_method(); // ok\r\n\r\n\t// calling non exported method \r\n\t// in private module\r\n\t// private_module.private_method(); // bad\r\n\r\n\tcontext.response.send('public_function');\r\n}\r\n```\r\n\r\n<a name='handling_404' />\r\n### handling 404\r\n\r\nUse wildcard functions to catch unhandled routes.\r\n\r\n```typescript\r\n// http:[host]:[port]/\r\nexport function index (context) { \r\n\r\n\tcontext.response.send('home page');\r\n}\r\n\r\n// http:[host]:[port]/(.*)\r\nexport function wildcard (context, path) {\r\n\r\n\tcontext.response.send(404, path + ' not found');\r\n}\r\n```\r\n<a name=\"serving_static_files\" />\r\n## serving static files\r\n\r\nUse wildcard functions with context.response.serve() to serve static content.\r\n\r\n```typescript\r\nexport module static {\r\n\t\r\n\t// http:[host]:[port]/static/(.*)\r\n\texport function wildcard(context, path) {\r\n\r\n\t\tcontext.response.serve('./static/', path);\r\n\t}\r\n}\r\n\r\n// http:[host]:[port]/\r\nexport function index (context) {\r\n\r\n\tcontext.response.send('home page');\r\n}\r\n\r\n// http:[host]:[port]/(.*)\r\nexport function wildcard(context, path) {\r\n\r\n\tcontext.response.send(404, path + ' not found');\r\n}\r\n```\r\n\r\n<a name=\"templating\" />\r\n## templating\r\n\r\nappex comes bundled with a built in template engine which is modelled on the Microsoft \r\nRazor templating engine. The following sections outline its use.\r\n\r\n<a name=\"template_overview\" />\r\n### overview\r\n\r\nThe appex template engine is available to all handlers by default. it is accessible\r\non the context.template property. the following is an example of its use.\r\n\r\n```\r\n//----------------------------------------------\r\n// view.txt\r\n//----------------------------------------------\r\n\r\n<ul>\r\n@for(var n in context.users) {\r\n\r\n\t@if(context.users[n].online) {\r\n\t\t\t\r\n\t\t<li>@(context.users[n].name)</li>\r\n\t}\r\n}\r\n</ul>\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\nexport function index(context) {\r\n\t\r\n    var users = [{name:'dave' , online : true}, \r\n                 {name:'smith', online : true}, \r\n                 {name:'jones', online : false}, \r\n                 {name:'alice', online : true}];\r\n\r\n    var text = context.template.render('./view.txt', { users: users });\r\n\t\r\n\tcontext.response.headers['Content-Type'] = 'text/html';\r\n\r\n    context.response.send(text);\r\n}\r\n\r\n```\r\n\r\n<a name=\"template_context\" />\r\n### context\r\n\r\neach template is passed a data context. this context allows the caller to \r\nsend data to the template for rendering. the context parameter is optional.\r\nthe example below is sending the users array to the template context for \r\nrendering.\r\n\r\n```\r\nexport function index(context) {\r\n\t\r\n    var users  = [{name:'dave' , online : true}, \r\n                 {name:'smith', online : true}, \r\n                 {name:'jones', online : false}, \r\n                 {name:'alice', online : true}];\r\n\r\n    context.response.send(context.template.render('./view.txt', { users: users }));\r\n}\r\n```\r\n\r\n<a name=\"template_syntax\" />\r\n### syntax\r\n\r\nappex templates support the following statements and syntax\r\n\r\n#### if statement\r\n\r\nif statments are supported.\r\n\r\n```\r\n@if(expression) {\r\n\tsome content\r\n}\r\n\r\n@if(a > 10) {\r\n\tsome content\r\n}\r\n\r\n@(user.loggedin) {\r\n\t<span>welcome</span>\r\n}\r\n```\r\n\r\n#### for statement\r\n\r\nthe following for loops are supported.\r\n\r\n```\r\n@for(var i = i; i < 100; i++) {\r\n\t@(i)\r\n}\r\n\r\n@for(var n in list) {\r\n\t@(list[n])\r\n}\r\n```\r\n\r\n#### expressions\r\n\r\nwill emit the value contained.\r\n\r\n```\r\n@('hello world')\r\n\r\n@(123)\r\n\r\n@(some_variable)\r\n```\r\n\r\n#### code blocks\r\n\r\ncode blocks can be useful for adding template side rendering logic.\r\n\r\n```\r\n@{\r\n\tvar message = 'hello'\r\n}\r\n\r\n@(message)\r\n```\r\n\r\n#### comments\r\n```\r\n@*\r\n\tthis comment will not be rendered!\r\n*@\r\n```\r\n\r\n<a name=\"template_layouts_and_sections\" />\r\n### layouts and sections\r\n\r\nappex templates support template inheritance.\r\n\r\nconsider the following where layout.txt defines the sections 'header' and 'content' and the view.txt overrides\r\nthese sections with its own content.\r\n\r\n```\r\n//----------------------------------------------\r\n// layout.txt\r\n//----------------------------------------------\r\n\r\n<html>\r\n\r\n\t<head>\r\n\t\t\r\n\t\t@section header\r\n\r\n\t</head>\r\n\r\n\t<body>\r\n\r\n\t\t@section content {\r\n\t\t\r\n\t\t\t<span>some default content</span>\r\n\t\t\t\r\n\t\t}\r\n\r\n\t</body>\r\n\t\r\n</html>\r\n\r\n//----------------------------------------------\r\n// view.txt\r\n//----------------------------------------------\r\n\r\n@layout 'layout.txt'\r\n\r\n@section header {\r\n\r\n\t<title>my page</title>\r\n}\r\n\r\n@section content {\r\n\r\n\t<p>overriding the layout.txt content section.</p>\r\n\r\n\t<ul>\r\n\t@for(var n in context.users) {\r\n\r\n\t\t@if(context.users[n].online) {\r\n\t\t\t\r\n\t\t\t<li>@(context.users[n].name)</li>\r\n\t\t}\r\n\t}\r\n\t</ul>\r\n}\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\nexport function index(context) {\r\n\t\r\n    var users = [{name:'dave' , online : true}, \r\n                 {name:'smith', online : true}, \r\n                 {name:'jones', online : false}, \r\n                 {name:'alice', online : true}];\r\n\r\n    var text = context.template.render('./view.txt', { users: users });\r\n\r\n    context.response.send(text);\r\n}\r\n```\r\n\r\nnote : when specifying a layout, the view will only render content within\r\nthe layouts section placeholders. \r\n\r\n<a name=\"render\" />\r\n### render\r\n\r\nappex templates also allow for partial views with the @render statment. consider the following \r\nwhich renders the nav.txt file into the layout.txt file.\r\n\r\n```\r\n//----------------------------------------------\r\n// nav.txt\r\n//----------------------------------------------\r\n<ul>\r\n\t<li>home</li>\r\n\t<li>about</li>\r\n\t<li>contact</li>\r\n</ul>\r\n\r\n//----------------------------------------------\r\n// layout.txt\r\n//----------------------------------------------\r\n\r\n<html>\r\n\t<head>\r\n\t\t\r\n\t\t@section header\r\n\r\n\t</head>\r\n\r\n\t<body>\r\n\t\t\r\n\t\t@render 'nav.txt'\r\n\r\n\t\t@section content {\r\n\t\t\r\n\t\t\t<span>some default content</span>\r\n\t\t\t\r\n\t\t}\r\n\r\n\t</body>\r\n\t\r\n</html>\r\n\r\n//----------------------------------------------\r\n// view.txt\r\n//----------------------------------------------\r\n\r\n@layout 'layout.txt'\r\n\r\n@section header {\r\n\r\n\t<title>my page</title>\r\n}\r\n\r\n@section content {\r\n\r\n\t<p>overriding the layout.txt content section.</p>\r\n\r\n\t<ul>\r\n\t@for(var n in context.users) {\r\n\r\n\t\t@if(context.users[n].online) {\r\n\t\t\t\r\n\t\t\t<li>@(context.users[n].name)</li>\r\n\t\t}\r\n\t}\r\n\t</ul>\r\n}\r\n\r\n//----------------------------------------------\r\n// program.ts\r\n//----------------------------------------------\r\n\r\nexport function index(context) {\r\n\t\r\n    var users = [{name:'dave' , online : true}, \r\n                 {name:'smith', online : true}, \r\n                 {name:'jones', online : false}, \r\n                 {name:'alice', online : true}];\r\n\r\n    var text = context.template.render('./view.txt', { users: users });\r\n\r\n    context.response.send(text);\r\n}\r\n```\r\n\r\n<a name=\"caching_and_devmode\" />\r\n### caching and devmode\r\n\r\nappex template content is not cached (the implementor is expected to handle their own caching)\r\nhowever the generated template code is. \r\n\r\nappex templates do inheriate the behaviour of the appex 'devmode' option. setting\r\ndevmode to 'true' will cause template code to be reloaded from disk and code generated with each \r\nrequest. setting devmode to false will load content from disk on first request, and \r\ncache the generated template code in memory for the lifetime of the application.\r\n\r\nin addition to this, a implementation where the devmode is false can override the caching \r\nbehaviour with the following.\r\n\r\n```typescript\r\nexport function index(context) {\r\n\r\n\t// manually override the template devmode option.\r\n\tcontext.template.option.devmode = true; \r\n\r\n\tcontext.response.send(context.template.render('./view.txt'))\r\n}\r\n```\r\n\r\n<a name=\"sitemaps\" />\r\n## sitemaps\r\n\r\nappex is able to derive sitemap metadata automatically from http endpoints created with\r\ntypescript modules and functions. This metadata is useful to generate sitemap.xml\r\nfiles, as well as helping to create site navigation links when combined a template\r\nengine.\r\n\r\n<a name=\"sitemap_generate\" />\r\n### generate sitemap\r\n\r\nappex sitemaps can be obtained from the context.sitemap property. \r\n\r\n```typescript\r\nexport function index(context) {\r\n\r\n\t// return all nodes in this site.\r\n\tcontext.response.json(context.sitemap)\r\n\r\n}\r\n```\r\n\r\nAdditionally, it may be helpful to isolate branches of the sitemap with the \r\ncontext.sitemap.get([qualifier]) function. as demonstrated below.\r\n\r\n```typescript\r\nexport module admin {\r\n\r\n\texport function index     (context) { }\r\n\r\n\texport function dashboard (context) { }\r\n\r\n\texport function content   (context) { }\r\n\r\n\texport module users {\r\n\r\n\t\texport function login(context) { }\r\n\r\n\t\texport function logout(context) { }\r\n\t}\r\n}\r\n\r\nexport function test(context) {\r\n\t\r\n\t// view all admin sitemap nodes\r\n\tcontext.response.json(context.sitemap.get('admin'))\r\n\r\n\t// view all admin.users sitemap nodes\r\n\t//context.response.json(context.sitemap.get('admin.users'))\r\n}\r\n```\r\n\r\n<a name=\"sitemap_metadata\" />\r\n### attribute metadata\r\n\r\neach sitemap node contains the attribute applied to the handler for which the node applies. With this\r\ndevelopers can apply custom metadata for a given node. as demonstrated below.\r\n\r\n```typescript\r\ndeclare var attribute;\r\n\r\nattribute({website:'http://mysite.com/'}) // global\r\n\r\nattribute('index', {title:'home page'})\r\nexport function index(context) {\r\n\r\n\tcontext.response.send('index')\r\n}\r\n\r\nattribute('about', {title: 'about page'})\r\nexport function about(context) {\r\n\r\n\tcontext.response.send('about')\r\n}\r\n\r\nattribute('sitemap', {title: 'sitemap page'})\r\nexport function sitemap(context) {\r\n\r\n\tcontext.response.json(context.sitemap)\r\n}\r\n```\r\n\r\nvisiting /sitemap will output the following.\r\n\r\n```typescript\r\n{\r\n    \"name\": \"sitemap\",\r\n    \"nodes\": [\r\n        {\r\n            \"name\": \"index\",\r\n            \"urls\": [\r\n                \"/\"\r\n            ],\r\n            \"website\": \"http://mysite.com/\",\r\n            \"title\": \"home page\"\r\n        },\r\n        {\r\n            \"name\": \"about\",\r\n            \"urls\": [\r\n                \"/about\"\r\n            ],\r\n            \"website\": \"http://mysite.com/\",\r\n            \"title\": \"about page\"\r\n        },\r\n        {\r\n            \"name\": \"sitemap\",\r\n            \"urls\": [\r\n                \"/sitemap\"\r\n            ],\r\n            \"website\": \"http://mysite.com/\",\r\n            \"title\": \"sitemap page\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n<a name=\"json_schema\" />\r\n## json schema\r\n\r\nappex provides functionality for generating json schemas from TypeScript classes\r\nand interfaces as well as tools for validating json data.\r\n\r\n<a name=\"generating_schema\" />\r\n### generating schema\r\n\r\nThe following demonstrates generating json schema from the following class\r\nhierarchy.\r\n\r\n```typescript\r\nexport module model {\r\n\r\n    /** a product */\r\n    export class Product {\r\n        \r\n        /** the product name */\r\n        public name        : string;\r\n\r\n        /** the product description */\r\n        public description : string;\r\n\r\n        /** the product cost */\r\n        public cost        : number;\r\n    } \r\n\r\n    /** a order */\r\n    export class Order {\r\n        \r\n        /** the product being ordered */\r\n        public products  : Product;\r\n    }\r\n\r\n    /** a customer */\r\n    export class Customer {\r\n\r\n        /** the customers firstname */\r\n        public firstname  : string;\r\n\r\n        /** the customers lastname */\r\n        public lastname   : string;\r\n\r\n        /** orders made by this customer */\r\n        public orders     : Order[];\r\n    }\r\n}\r\n\r\nexport function index (context:appex.web.IContext) {\r\n\t\r\n\t// pass the fully qualified name of the type.\r\n    var schema = context.schema.get('model.Customer');\r\n\r\n    context.response.json(schema);\r\n}\r\n```\r\n\r\nwhich generates the following json schema.\r\n\r\n```typescript\r\n{\r\n    \"id\": \"model.Customer\",\r\n    \"type\": \"object\",\r\n    \"description\": \"a customer\",\r\n    \"properties\": {\r\n        \"firstname\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"the customers firstname\",\r\n            \"required\": true\r\n        },\r\n        \"lastname\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"the customers lastname\",\r\n            \"required\": true\r\n        },\r\n        \"orders\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": {\r\n                    \"id\": \"model.Order\",\r\n                    \"type\": \"object\",\r\n                    \"description\": \"a order\",\r\n                    \"properties\": {\r\n                        \"products\": {\r\n                            \"id\": \"model.Product\",\r\n                            \"type\": \"object\",\r\n                            \"description\": \"a product\",\r\n                            \"properties\": {\r\n                                \"name\": {\r\n                                    \"type\": \"string\",\r\n                                    \"description\": \"the product name\",\r\n                                    \"required\": true\r\n                                },\r\n                                \"description\": {\r\n                                    \"type\": \"string\",\r\n                                    \"description\": \"the product description\",\r\n                                    \"required\": true\r\n                                },\r\n                                \"cost\": {\r\n                                    \"type\": \"number\",\r\n                                    \"description\": \"the product cost\",\r\n                                    \"required\": true\r\n                                }\r\n                            },\r\n                            \"required\": true\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \"description\": \"orders made by this customer\",\r\n            \"required\": true\r\n        }\r\n    }\r\n}\r\n```\r\na quick note...\r\n\r\nwhen generating schema from classes:\r\n\r\n* only public class variables will be emitted.\r\n* all properties will be marked as \"required\".\r\n\r\nwhen generating schema from interfaces:\r\n\r\n* all properties will be emitted. \r\n* all properties will be marked as \"required\" unless modified with '?'.\r\n\r\n<a name=\"validating_json\" />\r\n### validating json\r\n\r\nappex supports json schema validation from class and interface definitions. consider the following...\r\n\r\n```typescript\r\ninterface Customer {\r\n\r\n    firstname    : string;\r\n\r\n    lastname     : string;\r\n\r\n    age          : number;\r\n\r\n    emails       : string[];\r\n\r\n    option_a ?   : boolean; // optional\r\n\r\n    option_b ?   : boolean; // optional\r\n\r\n}\r\n\r\nexport function index(context) {\r\n\r\n    // a customer with invalid data.\r\n\r\n    var customer = {\r\n\r\n        firstname    : 'dave',\r\n\r\n        age          : '33',\r\n\r\n        emails       : [12345, 'dave@domain.com', true],\r\n\r\n        option_b     : 1,\r\n\r\n        option_c     : 1\r\n    }\r\n\r\n    // do validation.\r\n\r\n    var errors = context.schema.validate('Customer', customer);\r\n\r\n    if(errors) {\r\n\r\n        context.response.json(errors);\r\n    }\r\n}\r\n```\r\n\r\nwill output the following.\r\n\r\n```typescript\r\n[\r\n    {\r\n        \"message\": \"instance.lastname is required.\"\r\n    },\r\n    {\r\n        \"message\": \"instance.age is not a number\"\r\n    },\r\n    {\r\n        \"message\": \"instance.emails[0] is not a string\"\r\n    },\r\n    {\r\n        \"message\": \"instance.emails[2] is not a string\"\r\n    },\r\n    {\r\n        \"message\": \"instance.option_b is not a boolean\"\r\n    },\r\n    {\r\n        \"message\": \"instance.option_c unexpected property\"\r\n    }\r\n]\r\n```\r\n\r\n<a name=\"web_service_descriptions\">\r\n### web service descriptions\r\n\r\nFor those using appex for web services, developers can leverage appex json schema generation\r\nto generate endpoint metadata (think wsdl). Consider the following which leverages both appex \r\nschema generation and attributes to produce a metadata endpoint consumers of your\r\napi can use to see what data the endpoint http://example.com/customer/create accepts \r\nand returns.\r\n\r\n```typescript\r\nclass Request {\r\n\r\n    /** the customers firstname */\r\n    firstname : string;\r\n\r\n    /** the customers lastname */\r\n    lastname  : string;\r\n\r\n\t/** the customers lastname */\r\n}\r\n\r\nclass Response {\r\n\r\n    /** true on success  */\r\n    success:boolean;\r\n    \r\n    /** an array of validation errors  */\r\n    errors : string[];\r\n}\r\n\r\nattribute('metadata', {input  : 'Request', output : 'Response'})\r\nexport function metadata(context:appex.web.IContext) {\r\n\r\n    var metadata = {\r\n        \r\n\t\tendpoint : 'http://example.com/customer/create',\r\n\r\n        input    : context.schema.get(context.attribute.input),\r\n\r\n        output   : context.schema.get(context.attribute.output)\r\n    }\r\n\r\n    context.response.json(metadata)\r\n}\r\n```\r\n\r\nwhich outputs the following.\r\n\r\n```typescript\r\n{\r\n    \"endpoint\": \"http://example.com/customer/create\",\r\n    \"input\": {\r\n        \"id\": \"Request\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n            \"firstname\": {\r\n                \"type\": \"string\",\r\n                \"description\": \"the customers firstname\",\r\n                \"required\": true\r\n            },\r\n            \"lastname\": {\r\n                \"type\": \"string\",\r\n                \"description\": \"the customers lastname\",\r\n                \"required\": true\r\n            }\r\n        }\r\n    },\r\n    \"output\": {\r\n        \"id\": \"Response\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n            \"success\": {\r\n                \"type\": \"boolean\",\r\n                \"description\": \"true on success\",\r\n                \"required\": true\r\n            },\r\n            \"errors\": {\r\n                \"type\": \"array\",\r\n                \"description\": \"an array of validation errors\",\r\n                \"items\": {\r\n                    \"type\": \"string\"\r\n                },\r\n                \"required\": true\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\ntip: use the appex sitemap metadata to produce a metadata endpoint for all service methods \r\nin your application.\r\n\r\n\r\n<a name=\"reflection\" />\r\n## reflection\r\n\r\nappex provides a reflection api derived from TypeScript's type system that developers can \r\nleverage to reflect type information declared throughout their appex modules. \r\n\r\nthe following section outlines how to use the reflection api.\r\n\r\n<a name=\"reflect_everything\" />\r\n### reflect everything\r\n\r\nthe appex reflection api is passed on the context.module.reflection property and is available to all\r\nappex handler methods. The following code will JSON serialize everything declared in your appex\r\nproject and write it to the http response. \r\n\r\n```typescript\r\nexport function index (context:appex.web.Context) {\r\n    \r\n    context.response.json( context.module.reflection );\r\n}\r\n```\r\n\r\n<a name=\"reflect_specific_types\" />\r\n### reflect specific types\r\n\r\nIn typical scenarios, developers will want to leverage reflection meta data to generate\r\nservice contacts and client side models. the reflection api lets you access meta data \r\nfor the following types declared in your project. \r\n\r\n* modules\r\n* imports\r\n* classes\r\n* interfaces\r\n* functions\r\n* variables\r\n\r\nto access specific type metadata, use the reflection.get([qualifier]) method, as demonstrated below.\r\n\r\n```typescript\r\nexport module model {\r\n    \r\n    export class Customer {\r\n\r\n        public firstname   : string;\r\n\r\n        public lastname    : string;\r\n\r\n        public age         : number;\r\n    }\r\n}\r\n\r\nexport function index (context:appex.web.Context) {\r\n    \r\n    context.response.json( context.module.reflection.get('model.Customer') );\r\n}\r\n```\r\nand methods..\r\n\r\n```typescript\r\nfunction some_method(a:string, b:number, c?:boolean) : void { }\r\n\r\nexport function index (context:appex.web.Context) {\r\n    \r\n    context.response.json( context.module.reflection.get('some_method') );\r\n}\r\n```\r\n\r\n....and variables...\r\n\r\n```typescript\r\nvar some_variable:number = 10;\r\n\r\nexport function index (context:appex.web.Context) {\r\n    \r\n    context.response.json( context.module.reflection.get('some_variable') );\r\n}\r\n```\r\n\r\n<a name=\"developing_with_appex\" />\r\n## developing with appex\r\n\r\nThis section outlines development with appex.\r\n\r\n<a name=\"appex_declaration\" />\r\n### appex.d.ts declaration\r\n\r\nIf you develop on a TypeScript complicant editor (one that supports TS 0.9), appex comes bundled\r\nwith a declaration file you can reference in your project. If installing appex via npm, your\r\nreference should be as follows.\r\n\r\n```typescript\r\n/// <reference path=\"node_modules/appex/appex.d.ts\" />\r\n\r\nexport function index (context:appex.web.IContext) { \r\n    \r\n    context.response.send('hello');\r\n}\r\n\r\nexport function wildcard(context:appex.web.IContext, path:string) {\r\n\r\n    context.response.serve('./', path);\r\n}\r\n```\r\n\r\nBy referencing this in your project, you get the benefits of code completion and static type checking\r\nagainst both appex, and the nodejs core.\r\n\r\n![](https://raw.github.com/sinclairzx81/appex/master/artifacts/code-completion.jpg)\r\n\r\nAdditional declaration files may be obtained from [here](https://github.com/borisyankov/DefinitelyTyped)\r\n\r\n<a name=\"structuring_projects\" />\r\n### structuring projects\r\n\r\nappex includes TypeScript's ability to reference source files with the 'reference' element. appex \r\nwill traverse each source files references and include it as part of the compilation.\r\n\r\nDevelopers can use this functionality to logically split source files into reusable components of\r\nfunctionality, as demonstrated below. \r\n\r\n```typescript\r\n//---------------------------------------------------\t\r\n// file: app.js\r\n//---------------------------------------------------\r\n\r\nvar appex = require('appex');\r\n\r\nvar app = appex ({ program : './index.ts' });\r\n\r\napp.listen(3000);\r\n\r\n//---------------------------------------------------\t\r\n// file: index.ts\r\n//---------------------------------------------------\r\n\r\n/// <reference path=\"users.ts\" />\r\n/// <reference path=\"pages.ts\" />\r\n\r\n//---------------------------------------------------\t\r\n// file: users.ts\r\n//---------------------------------------------------\r\n\r\nexport module users {\r\n\t\r\n\t// http://[host]:[port]/users/login\r\n\texport function login  (context) { context.response.send('users.login') }\r\n\t\r\n\t// http://[host]:[port]/users/logout\r\n\texport function logout (context) { context.response.send('users.logout') }\r\n}\r\n\r\n//---------------------------------------------------\t\r\n// file: pages.ts\r\n//---------------------------------------------------\r\n\r\n// http://[host]:[port]/\r\nexport function index   (context) { context.response.send('home') }\r\n\r\n// http://[host]:[port]/about\r\nexport function about   (context) { context.response.send('about') }\r\n\r\n// http://[host]:[port]/contact\r\nexport function contact (context) { context.response.send('contact') }\r\n\r\nexport function wildcard (context, path) { context.response.send(404, ' not found') }\r\n\r\n```\r\n\r\n<a name=\"resources\" />\r\n## additional resources\r\n\r\n* [typescript homepage](http://www.typescriptlang.org/)\r\n* [typescript language specification](http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf)\r\n* [typescript declarations repository](https://github.com/borisyankov/DefinitelyTyped)\r\n\r\n<a name=\"license\" />\r\n## license\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n",
  "bugs": {
    "url": "https://github.com/sinclairzx81/appex/issues"
  },
  "_id": "appex@0.6.8",
  "_from": "appex@"
}
